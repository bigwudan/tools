#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include<errno.h>  
#include<sys/socket.h>  
#include<netinet/in.h>  
#include <sys/socket.h>
#include <netinet/in.h>
#include<arpa/inet.h>



#include <stdio.h>
#include <string.h>
#include "fastcgi.h"

#include <stdarg.h>  
#include <stddef.h>  
#include <setjmp.h>  
#include <google/cmockery.h>  

unsigned char nginx_str[] = {


0x01 ,0x01 ,0x00 ,0x01 ,0x00 ,0x08 ,0x00 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00
   ,0x00 ,0x00 ,0x01 ,0x04 ,0x00 ,0x01 ,0x03 ,0x38 ,0x00 ,0x00 ,0x0f ,0x11 ,0x53 ,0x43 ,0x52 ,0x49
   ,0x50 ,0x54 ,0x5f ,0x46 ,0x49 ,0x4c ,0x45 ,0x4e ,0x41 ,0x4d ,0x45 ,0x2f ,0x76 ,0x61 ,0x72 ,0x2f
   ,0x77 ,0x77 ,0x77 ,0x2f ,0x74 ,0x65 ,0x73 ,0x74 ,0x2e ,0x63 ,0x67 ,0x69 ,0x0c ,0x00 ,0x51 ,0x55
   ,0x45 ,0x52 ,0x59 ,0x5f ,0x53 ,0x54 ,0x52 ,0x49 ,0x4e ,0x47 ,0x0e ,0x03 ,0x52 ,0x45 ,0x51 ,0x55
   ,0x45 ,0x53 ,0x54 ,0x5f ,0x4d ,0x45 ,0x54 ,0x48 ,0x4f ,0x44 ,0x47 ,0x45 ,0x54 ,0x0c ,0x00 ,0x43
   ,0x4f ,0x4e ,0x54 ,0x45 ,0x4e ,0x54 ,0x5f ,0x54 ,0x59 ,0x50 ,0x45 ,0x0e ,0x00 ,0x43 ,0x4f ,0x4e
   ,0x54 ,0x45 ,0x4e ,0x54 ,0x5f ,0x4c ,0x45 ,0x4e ,0x47 ,0x54 ,0x48 ,0x0b ,0x09 ,0x53 ,0x43 ,0x52
   ,0x49 ,0x50 ,0x54 ,0x5f ,0x4e ,0x41 ,0x4d ,0x45 ,0x2f ,0x74 ,0x65 ,0x73 ,0x74 ,0x2e ,0x63 ,0x67
   ,0x69 ,0x0b ,0x09 ,0x52 ,0x45 ,0x51 ,0x55 ,0x45 ,0x53 ,0x54 ,0x5f ,0x55 ,0x52 ,0x49 ,0x2f ,0x74
   ,0x65 ,0x73 ,0x74 ,0x2e ,0x63 ,0x67 ,0x69 ,0x0c ,0x09 ,0x44 ,0x4f ,0x43 ,0x55 ,0x4d ,0x45 ,0x4e
   ,0x54 ,0x5f ,0x55 ,0x52 ,0x49 ,0x2f ,0x74 ,0x65 ,0x73 ,0x74 ,0x2e ,0x63 ,0x67 ,0x69 ,0x0d ,0x08
   ,0x44 ,0x4f ,0x43 ,0x55 ,0x4d ,0x45 ,0x4e ,0x54 ,0x5f ,0x52 ,0x4f ,0x4f ,0x54 ,0x2f ,0x76 ,0x61
   ,0x72 ,0x2f ,0x77 ,0x77 ,0x77 ,0x0f ,0x08 ,0x53 ,0x45 ,0x52 ,0x56 ,0x45 ,0x52 ,0x5f ,0x50 ,0x52
   ,0x4f ,0x54 ,0x4f ,0x43 ,0x4f ,0x4c ,0x48 ,0x54 ,0x54 ,0x50 ,0x2f ,0x31 ,0x2e ,0x31 ,0x0e ,0x04
   ,0x52 ,0x45 ,0x51 ,0x55 ,0x45 ,0x53 ,0x54 ,0x5f ,0x53 ,0x43 ,0x48 ,0x45 ,0x4d ,0x45 ,0x68 ,0x74
   ,0x74 ,0x70 ,0x11 ,0x07 ,0x47 ,0x41 ,0x54 ,0x45 ,0x57 ,0x41 ,0x59 ,0x5f ,0x49 ,0x4e ,0x54 ,0x45
   ,0x52 ,0x46 ,0x41 ,0x43 ,0x45 ,0x43 ,0x47 ,0x49 ,0x2f ,0x31 ,0x2e ,0x31 ,0x0f ,0x0c ,0x53 ,0x45
   ,0x52 ,0x56 ,0x45 ,0x52 ,0x5f ,0x53 ,0x4f ,0x46 ,0x54 ,0x57 ,0x41 ,0x52 ,0x45 ,0x6e ,0x67 ,0x69
   ,0x6e ,0x78 ,0x2f ,0x31 ,0x2e ,0x31 ,0x34 ,0x2e ,0x30 ,0x0b ,0x0d ,0x52 ,0x45 ,0x4d ,0x4f ,0x54
   ,0x45 ,0x5f ,0x41 ,0x44 ,0x44 ,0x52 ,0x31 ,0x39 ,0x32 ,0x2e ,0x31 ,0x36 ,0x38 ,0x2e ,0x31 ,0x2e
   ,0x31 ,0x30 ,0x33 ,0x0b ,0x05 ,0x52 ,0x45 ,0x4d ,0x4f ,0x54 ,0x45 ,0x5f ,0x50 ,0x4f ,0x52 ,0x54
   ,0x35 ,0x33 ,0x37 ,0x30 ,0x34 ,0x0b ,0x0d ,0x53 ,0x45 ,0x52 ,0x56 ,0x45 ,0x52 ,0x5f ,0x41 ,0x44
   ,0x44 ,0x52 ,0x31 ,0x39 ,0x32 ,0x2e ,0x31 ,0x36 ,0x38 ,0x2e ,0x31 ,0x2e ,0x31 ,0x31 ,0x31 ,0x0b
   ,0x02 ,0x53 ,0x45 ,0x52 ,0x56 ,0x45 ,0x52 ,0x5f ,0x50 ,0x4f ,0x52 ,0x54 ,0x38 ,0x30 ,0x0b ,0x01
   ,0x53 ,0x45 ,0x52 ,0x56 ,0x45 ,0x52 ,0x5f ,0x4e ,0x41 ,0x4d ,0x45 ,0x5f ,0x0f ,0x03 ,0x52 ,0x45
   ,0x44 ,0x49 ,0x52 ,0x45 ,0x43 ,0x54 ,0x5f ,0x53 ,0x54 ,0x41 ,0x54 ,0x55 ,0x53 ,0x32 ,0x30 ,0x30
   ,0x09 ,0x0d ,0x48 ,0x54 ,0x54 ,0x50 ,0x5f ,0x48 ,0x4f ,0x53 ,0x54 ,0x31 ,0x39 ,0x32 ,0x2e ,0x31
   ,0x36 ,0x38 ,0x2e ,0x31 ,0x2e ,0x31 ,0x31 ,0x31 ,0x0f ,0x0a ,0x48 ,0x54 ,0x54 ,0x50 ,0x5f ,0x43
   ,0x4f ,0x4e ,0x4e ,0x45 ,0x43 ,0x54 ,0x49 ,0x4f ,0x4e ,0x6b ,0x65 ,0x65 ,0x70 ,0x2d ,0x61 ,0x6c
   ,0x69 ,0x76 ,0x65 ,0x1e ,0x01 ,0x48 ,0x54 ,0x54 ,0x50 ,0x5f ,0x55 ,0x50 ,0x47 ,0x52 ,0x41 ,0x44
   ,0x45 ,0x5f ,0x49 ,0x4e ,0x53 ,0x45 ,0x43 ,0x55 ,0x52 ,0x45 ,0x5f ,0x52 ,0x45 ,0x51 ,0x55 ,0x45
   ,0x53 ,0x54 ,0x53 ,0x31 ,0x0f ,0x73 ,0x48 ,0x54 ,0x54 ,0x50 ,0x5f ,0x55 ,0x53 ,0x45 ,0x52 ,0x5f
   ,0x41 ,0x47 ,0x45 ,0x4e ,0x54 ,0x4d ,0x6f ,0x7a ,0x69 ,0x6c ,0x6c ,0x61 ,0x2f ,0x35 ,0x2e ,0x30
   ,0x20 ,0x28 ,0x57 ,0x69 ,0x6e ,0x64 ,0x6f ,0x77 ,0x73 ,0x20 ,0x4e ,0x54 ,0x20 ,0x31 ,0x30 ,0x2e
   ,0x30 ,0x3b ,0x20 ,0x57 ,0x69 ,0x6e ,0x36 ,0x34 ,0x3b ,0x20 ,0x78 ,0x36 ,0x34 ,0x29 ,0x20 ,0x41
   ,0x70 ,0x70 ,0x6c ,0x65 ,0x57 ,0x65 ,0x62 ,0x4b ,0x69 ,0x74 ,0x2f ,0x35 ,0x33 ,0x37 ,0x2e ,0x33
   ,0x36 ,0x20 ,0x28 ,0x4b ,0x48 ,0x54 ,0x4d ,0x4c ,0x2c ,0x20 ,0x6c ,0x69 ,0x6b ,0x65 ,0x20 ,0x47
   ,0x65 ,0x63 ,0x6b ,0x6f ,0x29 ,0x20 ,0x43 ,0x68 ,0x72 ,0x6f ,0x6d ,0x65 ,0x2f ,0x37 ,0x36 ,0x2e
   ,0x30 ,0x2e ,0x33 ,0x38 ,0x30 ,0x39 ,0x2e ,0x31 ,0x33 ,0x32 ,0x20 ,0x53 ,0x61 ,0x66 ,0x61 ,0x72
   ,0x69 ,0x2f ,0x35 ,0x33 ,0x37 ,0x2e ,0x33 ,0x36 ,0x0b ,0x76 ,0x48 ,0x54 ,0x54 ,0x50 ,0x5f ,0x41
   ,0x43 ,0x43 ,0x45 ,0x50 ,0x54 ,0x74 ,0x65 ,0x78 ,0x74 ,0x2f ,0x68 ,0x74 ,0x6d ,0x6c ,0x2c ,0x61
   ,0x70 ,0x70 ,0x6c ,0x69 ,0x63 ,0x61 ,0x74 ,0x69 ,0x6f ,0x6e ,0x2f ,0x78 ,0x68 ,0x74 ,0x6d ,0x6c
   ,0x2b ,0x78 ,0x6d ,0x6c ,0x2c ,0x61 ,0x70 ,0x70 ,0x6c ,0x69 ,0x63 ,0x61 ,0x74 ,0x69 ,0x6f ,0x6e
   ,0x2f ,0x78 ,0x6d ,0x6c ,0x3b ,0x71 ,0x3d ,0x30 ,0x2e ,0x39 ,0x2c ,0x69 ,0x6d ,0x61 ,0x67 ,0x65
   ,0x2f ,0x77 ,0x65 ,0x62 ,0x70 ,0x2c ,0x69 ,0x6d ,0x61 ,0x67 ,0x65 ,0x2f ,0x61 ,0x70 ,0x6e ,0x67
   ,0x2c ,0x2a ,0x2f ,0x2a ,0x3b ,0x71 ,0x3d ,0x30 ,0x2e ,0x38 ,0x2c ,0x61 ,0x70 ,0x70 ,0x6c ,0x69
   ,0x63 ,0x61 ,0x74 ,0x69 ,0x6f ,0x6e ,0x2f ,0x73 ,0x69 ,0x67 ,0x6e ,0x65 ,0x64 ,0x2d ,0x65 ,0x78
   ,0x63 ,0x68 ,0x61 ,0x6e ,0x67 ,0x65 ,0x3b ,0x76 ,0x3d ,0x62 ,0x33 ,0x14 ,0x0d ,0x48 ,0x54 ,0x54
   ,0x50 ,0x5f ,0x41 ,0x43 ,0x43 ,0x45 ,0x50 ,0x54 ,0x5f ,0x45 ,0x4e ,0x43 ,0x4f ,0x44 ,0x49 ,0x4e
   ,0x47 ,0x67 ,0x7a ,0x69 ,0x70 ,0x2c ,0x20 ,0x64 ,0x65 ,0x66 ,0x6c ,0x61 ,0x74 ,0x65 ,0x14 ,0x0e
   ,0x48 ,0x54 ,0x54 ,0x50 ,0x5f ,0x41 ,0x43 ,0x43 ,0x45 ,0x50 ,0x54 ,0x5f ,0x4c ,0x41 ,0x4e ,0x47
   ,0x55 ,0x41 ,0x47 ,0x45 ,0x7a ,0x68 ,0x2d ,0x43 ,0x4e ,0x2c ,0x7a ,0x68 ,0x3b ,0x71 ,0x3d ,0x30
   ,0x2e ,0x39 ,0x01 ,0x04 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x05 ,0x00 ,0x01 ,0x00 ,0x00
   ,0x00 ,0x00











};



void test_head(void **state) 
{  
	unsigned char buf[80000] = {0};
	unsigned char head_buf[3000] = {0};
	unsigned int position = 0;
	int ndata = 0;
	int npad = 0;
	int nhead = 0;

    
    
	struct wl_evbuffer *evbuf =  wl_evbuffer_new();
	//assert_int_equal(evbuf, 0);	
	assert_true(evbuf);
	
	fcgi_header f_head;

	
	// beg request
	f_head.version = 0x01;
	f_head.type = 0x01;
	f_head.requestIdB1 = 0x00;
	f_head.requestIdB0 = 0x01;
	f_head.contentLengthB1 = 0x00;
	f_head.contentLengthB0 = 0x08;
	f_head.paddingLength = 0x00;
	f_head.reserved = 0x00;
	ndata = fastcgi_assgin_header_tobuf(&f_head, buf);	
	wl_evbuffer_add(evbuf, buf, ndata);
	memset(buf, 0, sizeof(buf));
	//得到body
	fcgi_beginrequestbody body = {
		0x00,
		0x01,
		0x00,
		{0x00, 0x00, 0x00,0x00,0x00}	
	};
	ndata = fastcgi_assgin_beginrequestbody_tobuf(&body, buf);
	wl_evbuffer_add(evbuf, buf, ndata);
	memset(buf, 0, sizeof(buf));
	assert_true(ndata);	
	// end beg request

	//beg params
	struct kv_head kv_list_head;
	TAILQ_INIT(&kv_list_head);

	//1
	struct kv_list kv_1;
	kv_1.key = "k1";
	kv_1.value = "v1";

	TAILQ_INSERT_TAIL(&kv_list_head, &kv_1, next);		


	struct kv_list kv_2;
	kv_2.key = "k2";
	kv_2.value = "v2";

	TAILQ_INSERT_TAIL(&kv_list_head, &kv_2, next);		



	ndata =  fastcgi_assgin_kvrequestbody_tobuf(&kv_list_head, buf, &npad);
	

	f_head.version = 0x01;
	f_head.type = 0x04;
	f_head.requestIdB1 = 0x00;
	f_head.requestIdB0 = 0x01;
	f_head.contentLengthB1 = ndata>>8 & 0xff;
	f_head.contentLengthB0 = ndata & 0xff;
	f_head.paddingLength = npad;
	f_head.reserved = 0x00;
	
	nhead =  fastcgi_assgin_header_tobuf(&f_head, head_buf);	
	
	wl_evbuffer_add(evbuf, head_buf, nhead);
	wl_evbuffer_add(evbuf, buf, ndata);

	f_head.version = 0x01;
	f_head.type = 0x04;
	f_head.requestIdB1 = 0x00;
	f_head.requestIdB0 = 0x01;
	f_head.contentLengthB1 = 0x00;
	f_head.contentLengthB0 = 0x00;
	f_head.paddingLength = 0x00;
	f_head.reserved = 0x00;
    //加入00

	nhead =  fastcgi_assgin_header_tobuf(&f_head, head_buf);	
	wl_evbuffer_add(evbuf, head_buf, nhead);
	//end params
    
    //beg stdin
    char *tmp_str = "this is post";
    ndata = fastcgi_assgin_stdinbody_tobuf(buf, &npad, tmp_str, strlen(tmp_str));    

	f_head.version = 0x01;
	f_head.type = 0x05;
	f_head.requestIdB1 = 0x00;
	f_head.requestIdB0 = 0x01;
	f_head.contentLengthB1 = ndata >> 8 & 0xff;
	f_head.contentLengthB0 = ndata & 0xff;
	f_head.paddingLength = npad;
	f_head.reserved = 0x00;

    //head
	nhead =  fastcgi_assgin_header_tobuf(&f_head, head_buf);	
	wl_evbuffer_add(evbuf, head_buf, nhead);
    //body
	wl_evbuffer_add(evbuf, buf, ndata);
    // 00 head
	f_head.version = 0x01;
	f_head.type = 0x05;
	f_head.requestIdB1 = 0x00;
	f_head.requestIdB0 = 0x01;
	f_head.contentLengthB1 = 0x00;
	f_head.contentLengthB0 = 0x00;
	f_head.paddingLength = 0x00;
	f_head.reserved = 0x00;
    //head
	nhead =  fastcgi_assgin_header_tobuf(&f_head, head_buf);	
	wl_evbuffer_add(evbuf, head_buf, nhead);
    printf("over\n");


	int sockfd;
	int len = 0;
	// 连接服务器
	struct sockaddr_in serv;
	memset(&serv, 0, sizeof(serv));
	serv.sin_family = AF_INET;
	serv.sin_port = htons(7000);
	if( inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr) <= 0){  
		printf("inet_pton error for ");  
		exit(0);  
	}  

	if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){  
		printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);  
		exit(0);  
	}  


	//evutil_inet_pton(AF_INET, "114.215.85.234", &serv.sin_addr.s_addr);
	if( connect(sockfd, (struct sockaddr*)&serv, sizeof(serv)) < 0){  
		printf("connect error: %s(errno: %d)\n",strerror(errno),errno);  
		exit(0);  
	} 
	int count = 0;
	//len = write(sockfd, nginx_str, sizeof(nginx_str) );
	len = write(sockfd, evbuf->buffer, evbuf->off );
	printf("write len=%d\n", len);
	

	char test_buf[2000] = {0};


	len = read(sockfd, test_buf, sizeof(test_buf));

	printf("read len=%d\n", len);



} 


int main()
{
    const UnitTest tests[] = {  
        unit_test(test_head),  
    };  
    return run_tests(tests);  


}

